#include "quicksort.hsp"
#module _module_
    #deffunc random_shuffle array data, int size
        dim i,1:dim a,1:dim b,1:dim tmp,1
        randomize
        i = size
        repeat
            if(i <= 1):break
            a = i - 1:b = rnd(i)
            tmp = data(a):data(a) = data(b):data(b) = tmp
            i--
        loop
        dim i,0:dim a,0:dim b,0:dim tmp,0
    return
    #defcfunc AD int number
        ret = "" + (number / 10) + (number \ 10)
    return ret
#global

//画像用意
    buffer_size = 125.0
    buffer 100, buffer_size, buffer_size
        color 0, 255, 0:boxf
    buffer 101, buffer_size, buffer_size
        color 0, 0, 0:boxf
    buffer 99, buffer_size, buffer_size
        color 255, 255, 255:boxf
    celload "画像ファイル/盤面(空).png",100
    celload "画像ファイル/盤面(白).png",99
    celload "画像ファイル/盤面(黒).png",101
    celload "画像ファイル/盤面(候補).png",102
    celload "画像ファイル/盤面(カーソル).png",103

    gsel 0
//画面用意
    screen 0,buffer_size * 8, buffer_size * 8
    width ,,ginfo_dispx - ginfo_sizex + 2,0
//ゲノム用意
    dim black_genome,64
    dim white_genome,64
    dim board_score,64
    gosub *make_black_genome
    gosub *make_white_genome
//学習
    dim board,10,10
    dim can_count,2
    dim put_disk_pos,2,50
    dim put_disk_num,2
    win_count_black = 0
    win_count_white = 0
    repeat 10000
        gosub *reset
        gosub *othello
        gosub *assessment_board
        gosub *draw_board
        await
    loop
    gosub *saving_result
    dialog
end

*make_black_genome
    i = 0:repeat 64:black_genome(i) = i:i++:loop
    random_shuffle black_genome, 64
return

*make_white_genome
    i = 0:repeat 64:white_genome(i) = i:i++:loop
    random_shuffle white_genome, 64
return

*reset
    i = 0
    repeat 100:if(1 <= i \ 10 && i \ 10 <= 8 && 1 <= i / 10 && i / 10 <= 8){board(i \ 10,i / 10) = 0}else{board(i \ 10,i / 10) = 2}:i++:loop
    board(4,4) = -1:board(5,5) = -1:board(5,4) = 1:board(4,5) = 1

    i = 0
    repeat 50:put_disk_pos(0,i) = 0:put_disk_pos(1,i) = 0:i++:loop
    put_disk_num(0) = 0:put_disk_num(1) = 0
    turn = 1
return

*draw_board
    redraw 0
        i = 0
        repeat 8
            j = 0
            repeat 8
                pos j * buffer_size, i * buffer_size
                switch board(i + 1, j + 1)
                    case 0
                        celput 100,,buffer_size / 100.0,buffer_size / 100.0
                    swbreak
                    case 1
                        celput 101,,buffer_size / 100.0,buffer_size / 100.0
                    swbreak
                    case -1
                        celput 99,,buffer_size / 100.0,buffer_size / 100.0
                    swbreak
                swend
                j++
            loop
            i++
        loop
    redraw 1
return

*othello
    repeat
        gosub *check_can_put_disk
        if(can_count(0) == 0 and can_count(1) == 0):break
        turn *= -1
        //gosub *draw_board
        await
    loop
return

*check_can_put_disk
    can_square_count = 0
        i = 0
        repeat 64
            if(turn == 1):x = black_genome(i) \ 8 + 1:y = black_genome(i) / 8 + 1:else:x = white_genome(i) \ 8 + 1:y = white_genome(i) / 8 + 1
            if(board(x,y) == 0){
                //上
                    if(board(x, y - 1) == -turn){
                        k = -1
                        repeat
                            if(board(x, y + k) == turn){
                                can_square_count++
                                break
                            }else:if(board(x, y + k) == 2 || board(x, y + k) == 0 || board(x, y + k) == 3){
                                break
                            }
                            k--
                        loop
                    }
                //右
                    if(board(x + 1,y) == -turn){
                        k = 1
                        repeat 
                            if(board(x + k,y) == turn){
                                can_square_count++
                                break
                            }else:if(board(x + k,y) == 2 || board(x + k,y) == 0 || board(x + k,y) == 3){
                                break
                            }
                            k++
                        loop
                    }
                //下
                    if(board(x,y + 1) == -turn){
                        k = 1
                        repeat
                            if(board(x,y + k) == turn){
                                can_square_count++
                                break
                            }else:if(board(x,y + k) == 2 || board(x,y + k) == 0 || board(x,y + k) == 3){
                                break
                            }
                            k++
                        loop
                    }
                //左
                    if(board(x - 1,y) == -turn){
                        k = -1
                        repeat 
                            if(board(x + k,y) == turn){
                                can_square_count++
                                break
                            }else:if(board(x + k,y) == 2 || board(x + k,y) == 0 || board(x + k,y) == 3){
                                break
                            }
                            k--
                        loop
                    }
                //右上
                    if(board(x + 1,y - 1) == -turn){
                        k = 1
                        repeat
                            if(board(x + k,y - k) == turn){
                                can_square_count++
                                break
                            }else:if(board(x + k,y - k) == 2 || board(x + k,y - k) == 0 || board(x + k,y - k) == 3){
                                break
                            }
                            k++
                        loop
                    }
                //右下
                    if(board(x + 1,y + 1) == -turn){
                        k = 1
                        repeat
                            if(board(x + k,y + k) == turn){
                                can_square_count++
                                break
                            }else:if(board(x + k,y + k) == 2 || board(x + k,y + k) == 0 || board(x + k,y + k) == 3){
                                break
                            }
                            k++
                        loop
                    }
                //左下
                    if(board(x - 1,y + 1) == -turn){
                        k = 1
                        repeat
                            if(board(x - k,y + k) == turn){
                                can_square_count++
                                break
                            }else:if(board(x - k,y + k) == 2 || board(x - k,y + k) == 0 || board(x - k,y + k) == 3){
                                break
                            }
                            k++
                        loop
                    }
                //左上
                    if(board(x - 1,y - 1) == -turn){
                        k = 1
                        repeat
                            if(board(x - k,y - k) == turn){
                                can_square_count++
                                break
                            }else:if(board(x - k,y - k) == 2 || board(x - k,y - k) == 0 || board(x - k,y - k) == 3){
                                break
                            }
                            k++
                        loop
                    }
                
                //ひっくり返す
                    if(can_square_count != 0):gosub *put_disk:break
            }
            i++
        loop
        if(turn == 1):can_count(0) = can_square_count:else:can_count(1) = can_square_count
return

*put_disk
    putx = x:puty = y
    if(turn == 1){
        put_disk_pos(0,put_disk_num(0)) = (x - 1) + (y - 1) * 8
        put_disk_num(0)++
    }else{
        put_disk_pos(1,put_disk_num(1)) = (x - 1) + (y - 1) * 8
        put_disk_num(1)++
    }
    //上
        k = 1
        repeat
            if(board(putx,puty - k) == turn){
                l = 0
                repeat k
                    board(putx,puty - l) = turn
                    l++
                loop
                break
            }else:if(board(putx,puty - k) == 2 || board(putx,puty - k) == 0 || board(putx,puty - k) == 3){
                break
            }
            k++
        loop
    //右上
        k = 1
        repeat
            if(board(putx + k,puty - k) == turn){
                l = 0
                repeat k
                    board(putx + l,puty - l) = turn
                    l++
                loop
                break
            }else:if(board(putx + k,puty - k) == 2 || board(putx + k,puty - k) == 0 || board(putx + k,puty - k) == 3){
                break
            }
            k++
        loop
    //右
        k = 1
        repeat
            if(board(putx + k,puty) == turn){
                l = 0
                repeat k
                    board(putx + l,puty) = turn
                    l++
                loop
                break
            }else:if(board(putx + k,puty) == 2 || board(putx + k,puty) == 0 || board(putx + k,puty) == 3){
                break
            }
            k++
        loop
    //右下
        k = 1
        repeat
            if(board(putx + k,puty + k) == turn){
                l = 0
                repeat k
                    board(putx + l,puty + l) = turn
                    l++
                loop
                break
            }else:if(board(putx + k,puty + k) == 2 || board(putx + k,puty + k) == 0 || board(putx + k,puty + k) == 3){
                break
            }
            k++
        loop
    //下
        k = 1
        repeat
            if(board(putx,puty + k) == turn){
                l = 0
                repeat k
                    board(putx,puty + l) = turn
                    l++
                loop
                break
            }else:if(board(putx,puty + k) == 2 || board(putx,puty + k) == 0 || board(putx,puty + k) == 3){
                break
            }
            k++
        loop
    //左下
        k = 1
        repeat
            if(board(putx - k,puty + k) == turn){
                l = 0
                repeat k
                    board(putx - l,puty + l) = turn
                    l++
                loop
                break
            }else:if(board(putx - k,puty + k) == 2 || board(putx - k,puty + k) == 0 || board(putx - k,puty + k) == 3){
                break
            }
            k++
        loop
    //左
        k = 1
        repeat
            if(board(putx - k,puty) == turn){
                l = 0
                repeat k
                    board(putx - l,puty) = turn
                    l++
                loop
                break
            }else:if(board(putx - k,puty) == 2 || board(putx - k,puty) == 0 || board(putx - k,puty) == 3){
                break
            }
            k++
        loop
    //左上
        k = 1
        repeat
            if(board(putx - k,puty - k) == turn){
                l = 0
                repeat k
                    board(putx - l,puty - l) = turn
                    l++
                loop
                break
            }else:if(board(putx - k,puty - k) == 2 || board(putx - k,puty - k) == 0 || board(putx - k,puty - k) == 3){
                break
            }
            k++
        loop
return

*assessment_board
    i = 0:count_black = 0:count_white = 0
    repeat 100
        if(board(i \ 10,i / 10) == 1):count_black++:else:if(board(i \ 10,i / 10) == -1):count_white++
        i++
    loop

    if(count_black > count_white){
        win_count_black++
        i = 0
        repeat put_disk_num(0)
            board_score(put_disk_pos(0,i)) += 3;count_black - count_white
            i++
        loop
        i = 0
        repeat put_disk_num(1)
            board_score(put_disk_pos(1,i)) += 1;count_black - count_white
            i++
        loop
        gosub *make_white_genome
    }else:if(count_black < count_white){
        win_count_white++;
        i = 0
        repeat put_disk_num(0)
            board_score(put_disk_pos(0,i)) += 1;count_white - count_black
            i++
        loop
        i = 0
        repeat put_disk_num(1)
            board_score(put_disk_pos(1,i)) += 3;count_white - count_black
            i++
        loop
        gosub *make_black_genome
    }else{
        if(win_count_black > win_count_white){
            gosub *make_white_genome
        }else:if(win_count_black > win_count_white){
            gosub *make_black_genome
        }else{
            gosub *make_white_genome
            gosub *make_black_genome
        }
    }
return

*saving_result
    score = ""
    notesel score
    repeat 64
        noteadd "" + board_score(cnt)
    loop
    time = "学習結果/" + AD(gettime(1)) + "." + AD(gettime(3)) + "." + AD(gettime(4)) + "." + AD(gettime(5)) + "." + AD(gettime(6))
    notesave time + ".sco"

    dim genome,64
    repeat 64
        genome(cnt) = cnt + 1
    loop

    qsortDec board_score,genome,0,63

    gene = ""
    notesel gene
    repeat 64
        noteadd ""+genome(cnt)
    loop
    notesave "学習結果/ゲノム/genome.gen"
return