#include "quicksort.hsp"
#include "hsp3util.as"
screen 0,1000,1000
width ,,ginfo_dispx - ginfo_sizex + 1,0

celload "盤面(空).png",100
celload "盤面(白).png",99
celload "盤面(黒).png",101

randomize

//初期遺伝子生成
    dim genome,100
    i = 0:repeat 100:genome(i) = i:i++:loop
    i = 100
    repeat
        if(i <= 1):break
        a = i - 1:b = rnd(i)
        tmp = genome(a):genome(a) = genome(b):genome(b) = tmp
        i--
    loop
/*今回の学習方法。
        1:ゲノムの上から順に駒を置いていく。
        2:置かれた駒を黒白別に記録していく。
        3:勝敗が決まった後、board_scoreを更新する(負けたら-(駒の数),勝ったら+(駒の数))。
        4:board_scoreを降順に並べ替え、ゲノムを更新する。*/
//スコアを初期化
    dim board_score,100

//学習開始
    //オセロ
        repeat 1000000
            dim board,10,10//0:空白 1:黒 -1:白 2:壁 3:置ける
            dim can_count,2
            dim put_disk_pos,2,50
            dim put_disk_num,2
            //盤面初期化
                gosub *reset_board
            //メイン
            repeat
                gosub *check_can_put_disk
                if(can_count(0) == 0 and can_count(1) == 0):break
                turn *= -1
            loop
            await
            gosub *draw_board
            //評価 & 更新
            gosub *assessment_board
        loop
        screen 1
        font "",12
        i = 0
        repeat 100
            pos (i \ 10) * 40,(i / 10) * 40
            mes board_score(i)
            i++
        loop
        gene = ""
        notesel gene
        i = 0
        repeat 100
            noteadd "" + board_score(i)
            i++
        loop
        gettimestr nowtime
        notesel gene
        notesave "" + 10 + "score.txt"
        stop
    *check_can_put_disk
        can_square_count = 0
        i = 0
        repeat 100
            x = genome(i) \ 10:y = genome(i) / 10
            if(board(x,y) == 0){
                //上
                    if(board(x, y - 1) == -turn){
                        k = -1
                        repeat
                            if(board(x, y + k) == turn){
                                can_square_count++
                                break
                            }else:if(board(x, y + k) == 2 || board(x, y + k) == 0 || board(x, y + k) == 3){
                                break
                            }
                            k--
                        loop
                    }
                //右
                    if(board(x + 1,y) == -turn){
                        k = 1
                        repeat 
                            if(board(x + k,y) == turn){
                                can_square_count++
                                break
                            }else:if(board(x + k,y) == 2 || board(x + k,y) == 0 || board(x + k,y) == 3){
                                break
                            }
                            k++
                        loop
                    }
                //下
                    if(board(x,y + 1) == -turn){
                        k = 1
                        repeat
                            if(board(x,y + k) == turn){
                                can_square_count++
                                break
                            }else:if(board(x,y + k) == 2 || board(x,y + k) == 0 || board(x,y + k) == 3){
                                break
                            }
                            k++
                        loop
                    }
                //左
                    if(board(x - 1,y) == -turn){
                        k = -1
                        repeat 
                            if(board(x + k,y) == turn){
                                can_square_count++
                                break
                            }else:if(board(x + k,y) == 2 || board(x + k,y) == 0 || board(x + k,y) == 3){
                                break
                            }
                            k--
                        loop
                    }
                //右上
                    if(board(x + 1,y - 1) == -turn){
                        k = 1
                        repeat
                            if(board(x + k,y - k) == turn){
                                can_square_count++
                                break
                            }else:if(board(x + k,y - k) == 2 || board(x + k,y - k) == 0 || board(x + k,y - k) == 3){
                                break
                            }
                            k++
                        loop
                    }
                //右下
                    if(board(x + 1,y + 1) == -turn){
                        k = 1
                        repeat
                            if(board(x + k,y + k) == turn){
                                can_square_count++
                                break
                            }else:if(board(x + k,y + k) == 2 || board(x + k,y + k) == 0 || board(x + k,y + k) == 3){
                                break
                            }
                            k++
                        loop
                    }
                //左下
                    if(board(x - 1,y + 1) == -turn){
                        k = 1
                        repeat
                            if(board(x - k,y + k) == turn){
                                can_square_count++
                                break
                            }else:if(board(x - k,y + k) == 2 || board(x - k,y + k) == 0 || board(x - k,y + k) == 3){
                                break
                            }
                            k++
                        loop
                    }
                //左上
                    if(board(x - 1,y - 1) == -turn){
                        k = 1
                        repeat
                            if(board(x - k,y - k) == turn){
                                can_square_count++
                                break
                            }else:if(board(x - k,y - k) == 2 || board(x - k,y - k) == 0 || board(x - k,y - k) == 3){
                                break
                            }
                            k++
                        loop
                    }
                
                //ひっくり返す
                    if(can_square_count != 0):break
            }
            i++
        loop
        if(turn == 1):can_count(0) = can_square_count:else:can_count(1) = can_square_count
        if(can_square_count != 0):gosub *put_disk
    return
    *draw_board
        redraw 0
            i = 0
            repeat 10
                j = 0
                repeat 10
                    pos i * 100,j * 100
                    switch board(i,j)
                        case 0
                            celput 100,,1.0,1.0
                        swbreak
                        case 1
                            celput 101,,1.0,1.0
                        swbreak
                        case -1
                            celput 99,,1.0,1.0
                        swbreak
                    swend
                    j++
                loop
                i++
            loop
        redraw 1
    return

    *put_disk
        putx = x:puty = y
        if(turn == 1){
            put_disk_pos(0,put_disk_num(0)) = x + y * 10
            put_disk_num(0)++
        }else{
            put_disk_pos(1,put_disk_num(1)) = x + y * 10
            put_disk_num(1)++
        }
        //上
            k = 1
            repeat
                if(board(putx,puty - k) == turn){
                    l = 0
                    repeat k
                        board(putx,puty - l) = turn
                        l++
                    loop
                    break
                }else:if(board(putx,puty - k) == 2 || board(putx,puty - k) == 0 || board(putx,puty - k) == 3){
                    break
                }
                k++
            loop
        //右上
            k = 1
            repeat
                if(board(putx + k,puty - k) == turn){
                    l = 0
                    repeat k
                        board(putx + l,puty - l) = turn
                        l++
                    loop
                    break
                }else:if(board(putx + k,puty - k) == 2 || board(putx + k,puty - k) == 0 || board(putx + k,puty - k) == 3){
                    break
                }
                k++
            loop
        //右
            k = 1
            repeat
                if(board(putx + k,puty) == turn){
                    l = 0
                    repeat k
                        board(putx + l,puty) = turn
                        l++
                    loop
                    break
                }else:if(board(putx + k,puty) == 2 || board(putx + k,puty) == 0 || board(putx + k,puty) == 3){
                    break
                }
                k++
            loop
        //右下
            k = 1
            repeat
                if(board(putx + k,puty + k) == turn){
                    l = 0
                    repeat k
                        board(putx + l,puty + l) = turn
                        l++
                    loop
                    break
                }else:if(board(putx + k,puty + k) == 2 || board(putx + k,puty + k) == 0 || board(putx + k,puty + k) == 3){
                    break
                }
                k++
            loop
        //下
            k = 1
            repeat
                if(board(putx,puty + k) == turn){
                    l = 0
                    repeat k
                        board(putx,puty + l) = turn
                        l++
                    loop
                    break
                }else:if(board(putx,puty + k) == 2 || board(putx,puty + k) == 0 || board(putx,puty + k) == 3){
                    break
                }
                k++
            loop
        //左下
            k = 1
            repeat
                if(board(putx - k,puty + k) == turn){
                    l = 0
                    repeat k
                        board(putx - l,puty + l) = turn
                        l++
                    loop
                    break
                }else:if(board(putx - k,puty + k) == 2 || board(putx - k,puty + k) == 0 || board(putx - k,puty + k) == 3){
                    break
                }
                k++
            loop
        //左
            k = 1
            repeat
                if(board(putx - k,puty) == turn){
                    l = 0
                    repeat k
                        board(putx - l,puty) = turn
                        l++
                    loop
                    break
                }else:if(board(putx - k,puty) == 2 || board(putx - k,puty) == 0 || board(putx - k,puty) == 3){
                    break
                }
                k++
            loop
        //左上
            k = 1
            repeat
                if(board(putx - k,puty - k) == turn){
                    l = 0
                    repeat k
                        board(putx - l,puty - l) = turn
                        l++
                    loop
                    break
                }else:if(board(putx - k,puty - k) == 2 || board(putx - k,puty - k) == 0 || board(putx - k,puty - k) == 3){
                    break
                }
                k++
            loop
    return

    *reset_board
        i = 0
        repeat 10:board(i,0) = 2:board(i,9) = 2:board(0,i) = 2:board(9,i) = 2:i++:loop
        board(4,4) = -1:board(5,5) = -1:board(5,4) = 1:board(4,5) = 1
        //ターン初期化
            turn = 1//1:黒 -1:白
    return
    
    *assessment_board
        i = 0:count_black = 0:count_white = 0
        repeat 100
            if(board(i \ 10,i / 10) == 1):count_black++:else:if(board(i \ 10,i / 10) == -1):count_white++
            i++
        loop
        if(count_black > count_white){
            i = 0
            repeat put_disk_num(0)
                board_score(put_disk_pos(0,i)) += count_black - count_white
                i++
            loop
            i = 0
            repeat put_disk_num(1)
                board_score(put_disk_pos(1,i)) -= count_black - count_white
                i++
            loop
            gosub *genome_recombination
        }else:if(count_black < count_white){
            i = 0
            repeat put_disk_num(0)
                board_score(put_disk_pos(0,i)) -= count_white - count_black
                i++
            loop
            i = 0
            repeat put_disk_num(1)
                board_score(put_disk_pos(1,i)) += count_white - count_black
                i++
            loop
            gosub *genome_recombination
        }else{
            gosub *genome_recombination
        }
    return

    *genome_recombination
        i = 100
        repeat
            if(i <= 1):break
            a = i - 1:b = rnd(i)
            tmp = genome(a):genome(a) = genome(b):genome(b) = tmp
            i--
        loop
    return