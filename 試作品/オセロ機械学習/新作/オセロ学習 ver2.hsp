#module _othello_
    //関数定義
        #deffunc ClearField array field
            i = 0
            repeat 10
                j = 0
                repeat 10
                    field.i.j = 0
                    j++
                loop
                i++
            loop
            field.4.4 = 1
            field.5.5 = 1
            field.4.5 = -1
            field.5.4 = -1
            i = 0
            repeat 10
                field.i.0 = 10
                field.i.9 = 10
                field.0.i = 10
                field.9.i = 10
                i++
            loop
        return
        #deffunc DrawField array field//描画
            redraw 0
                i = 1
                repeat 8
                    j = 1
                    repeat 8
                        pos (i - 1) * 10, (j - 1) * 10
                        if(field.i.j == 0){
                            celput 1,, 1.0, 1.0
                        }else:if(field.i.j == 1){
                            celput 2,, 1.0, 1.0
                        }else:if(field.i.j == -1){
                            celput 3,, 1.0, 1.0
                        }else:if(field.i.j == 2 || field.i.j == -2){
                            celput 4,, 1.0, 1.0
                        }
                        j++
                    loop
                    i++
                loop
            redraw 1
        return
        #defcfunc CheckCanPut array field, var turn
            //各マスについてみる
            dim dx, 8 : dx = 0, 1, 1, 1, 0, -1, -1, -1
            dim dy, 8 : dy = -1, -1, 0, 1, 1, 1, 0, -1
            count_can_put = 0
            checkx = 1
            repeat 8
                checky = 1
                repeat 8
                    if(field.checkx.checky == 0 || field.checkx.checky == 2){
                        i = 0
                        repeat 8
                            if(field(checkx + dx.i, checky + dy.i) == -turn){
                                j = 1
                                repeat
                                    switch field(checkx + dx(i) * j, checky + dy(i) * j)
                                        case turn
                                            field(checkx, checky) = 2
                                            count_can_put++;
                                        case 0
                                        case 10
                                        case 2
                                            break
                                        swbreak
                                    swend
                                    j++
                                loop
                            }
                            i++
                        loop
                    }
                    checky++
                loop
                checkx++
            loop
        return count_can_put
        #deffunc PutDisk array field, var turn, int putx, int puty
            dim dx, 8 : dx = 0, 1, 1, 1, 0, -1, -1, -1
            dim dy, 8 : dy = -1, -1, 0, 1, 1, 1, 0, -1
            px = putx : py = puty
            if(field(px, py) == 2){
                i = 0
                repeat 8
                    j = 1
                    repeat 8
                        if(field(px + j * dx.i, py + j * dy.i) == turn){
                            k = 0
                            repeat j + 1
                                field(px + k * dx.i, py + k * dy.i) = turn
                                k++
                            loop
                            break
                        }else:if(field(px + j * dx.i, py + j * dy.i) == 2 || field(px + j * dx.i, py + j * dy.i) == 10 || field(px + j * dx.i, py + j * dy.i) == 0){
                            break
                        }
                        j++
                    loop
                    i++
                loop
            }
            i = 1
            repeat 8
                j = 1
                repeat 8
                    if(field.i.j == 2 || field.i.j == -2) : field.i.j = 0
                    j++
                loop
                i++
            loop
        return
#global
#module _NeuralNetwork_
    //関数定義
        #deffunc AssessmentBoard array field, var turn, array NNWeight, var putx, var puty, int iter, int len
            dim BufferField, 10, 10
            score = -2147483647
            x = 1
            repeat 8
                y = 1
                repeat 8
                    i = 0
                    repeat 10
                        j = 0
                        repeat 10
                            BufferField.i.j = field.i.j
                            j++
                        loop
                        i++
                    loop
                    if(BufferField.x.y == 2){
                        PutDisk BufferField, turn, x, y
                        bufscore = NeuralNetwork(BufferField, NNWeight, iter, len)
                        if(bufscore > score){
                            score = bufscore
                            putx = x
                            puty = y
                        }
                    }
                    y++
                loop
                x++
            loop
        return
        #defcfunc NeuralNetwork array field, array NNWeight, int iter, int len
            dim InputLayer, 64
            dim MiddleLayer, 8
            dim OutputLayer, 1

            i = 0
            repeat 64
                InputLayer.i = field(i \ 8 + 1, i / 8 + 1)
                j = 0
                repeat 8
                    MiddleLayer(j) += NNWeight(i * 8 + j, iter) * InputLayer(i)
                    j++
                loop
                i++
            loop

            i = 0
            repeat 8
                j = 0
                repeat 1
                    OutputLayer(j) += NNWeight(512 + i * 1 + j, iter) * MiddleLayer(i)
                    j++
                loop
                i++
            loop
        return OutputLayer
#global
#module _GA_
    //ソート
        #deffunc SortScore array score, array gen, int gen_num, int len
            //選択ソート
            i = 0
            repeat gen_num - 1
                min = i
                j = i + 1
                repeat
                    if(j >= gen_num):break;
                    if(score(j) > score(min)):min = j; 
                    j++
                loop
                tmp = score(i):score(i) = score(min):score(min) = tmp
                j = 0
                repeat len
                    tmp = gen(j, i):gen(j, i) = gen(min, i):gen(min, i) = tmp
                    j++
                loop
                i++
            loop
        return
#global
//画像を用意
    buffer 1, 10, 10
        color 0, 0, 0 : boxf
        color 0, 255, 0 : boxf 1, 1, 8, 8
    buffer 2, 10, 10
        color 0, 0, 0 : boxf
        color 0, 255, 0 : boxf 1, 1, 8, 8
        color 0, 0, 0 : circle 3, 3, 6, 6
    buffer 3, 10, 10
        color 0, 0, 0 : boxf
        color 0, 255, 0 : boxf 1, 1, 8, 8
        color 255, 255, 255 : circle 3, 3, 6, 6
    buffer 4, 10, 10
        color 0, 0, 0 : boxf
        color 0, 255, 0 : boxf 1, 1, 8, 8
        color 128, 128, 128 : circle 3, 3, 6, 6
    buffer 5, 10, 10
        color 0, 0, 0 : boxf
        color 255, 255, 0 : boxf 1, 1, 8, 8
gsel 0

//変数の定義初期化
    dim field, 10, 10
    ClearField field
    turn = 1

    len = 520
    biont_num = 10
    generation_num = 0

    dim NNWeightBlack, 520, biont_num
    dim NNWeightWhite, 520, biont_num
    dim New_NNWeightBlack, len, biont_num
    dim New_NNWeightWhite, len, biont_num
    dim score_black, biont_num
    dim score_white, biont_num

    note = ""
    randomize
    j = 0
    repeat biont_num
        i = 0
        repeat 520
            NNWeightBlack.i.j = rnd(101) - 50
            NNWeightWhite.i.j = rnd(101) - 50
            i++
        loop
        j++
    loop
    
    
//メイン
    screen 0, 20 * 8, 20 * 8
repeat
    //対戦させる(評価関数)
        i = 0
        repeat biont_num
            score_black.i = 0
            score_white.i = 0
            i++
        loop
        i = 0
        repeat biont_num
            j = 0
            repeat biont_num
                //対戦させる
                    ClearField field
                    turn = 1
                    repeat
                        k = 0
                        repeat 2
                            if(CheckCanPut(field, turn) != 0) : break
                            turn *= -1
                            k++
                        loop
                        if(k == 2) : DrawField field : break

                        putx = 1 : puty = 1 : score = 0

                        if(turn == 1) : AssessmentBoard field, turn, NNWeightBlack, putx, puty, i, len : else  : AssessmentBoard field, turn, NNWeightWhite, putx, puty, j, len

                        PutDisk field, turn, putx, puty
                        turn *= -1
                    loop
                    
                    DrawField field
                    await
                //点計算
                    black_num = 0
                    white_num = 0
                    k = 1
                    repeat 8
                        l = 1
                        repeat 8
                            if(field.k.l == 1) : black_num++ : else : if(field.k.l == -1) : white_num++;        
                            l++
                        loop
                        k++
                    loop
                    if(black_num > white_num){
                        score_black.i += 2
                    }else : if(black_num == white_num){
                        score_black.i += 1 : score_white.j += 1
                    }else{
                        score_white.j += 2;
                    }
                j++
            loop
            i++
        loop
    //ソート
        SortScore score_black, NNWeightBlack, biont_num, len
        SortScore score_white, NNWeightWhite, biont_num, len
    //交叉
        //上位3つを保存
            i = 0
            childlen_num = 0
            repeat 3
                j = 0
                repeat len
                    New_NNWeightBlack.j.childlen_num = NNWeightBlack.j.childlen_num
                    New_NNWeightWhite.j.childlen_num = NNWeightWhite.j.childlen_num
                    j++
                loop
                i++ : childlen_num++
            loop
        //交叉
            i = 0
            repeat
                j = i + 1
                repeat
                    //ここから本格的な交叉(二点交叉)
                        k = 0
                        repeat len
                            New_NNWeightBlack.k.childlen_num = NNWeightBlack.k.j
                            New_NNWeightBlack.k.childlen_num + 1 = NNWeightBlack.k.i
                            New_NNWeightWhite.k.childlen_num = NNWeightWhite.k.j
                            New_NNWeightWhite.k.childlen_num + 1 = NNWeightWhite.k.i
                            k++
                        loop
                        left = rnd(len):right = rnd(len)
                        if(left > right):tmp = left:left = right:right = tmp
                        k = left
                        repeat
                            if(k > right):break
                            New_NNWeightBlack(k, childlen_num) = NNWeightBlack(k, i)
                            New_NNWeightBlack(k, childlen_num + 1) = NNWeightBlack(k, j)
                            k++
                        loop
                        left = rnd(len):right = rnd(len)
                        if(left > right):tmp = left:left = right:right = tmp
                        k = left
                        repeat
                            if(k > right):break
                            New_NNWeightWhite(k, childlen_num) = NNWeightWhite(k, i)
                            New_NNWeightWhite(k, childlen_num + 1) = NNWeightWhite(k, j)
                            k++
                        loop
                    //突然変異
                        k = 0
                        repeat len
                            if(rnd(len) == 0){
                                New_NNWeightBlack(k, childlen_num) = rnd(101) - 50
                            }
                            if(rnd(len) == 0){
                                New_NNWeightBlack(k, childlen_num + 1) = rnd(101) - 50
                            }
                            if(rnd(len) == 0){
                                New_NNWeightWhite(k, childlen_num) = rnd(101) - 50
                            }
                            if(rnd(len) == 0){
                                New_NNWeightWhite(k, childlen_num + 1) = rnd(101) - 50
                            }
                            k++
                        loop
                    j++ : childlen_num += 2;
                    if(j >= 3) : break
                loop
                i++
                if(i >= 3) : break
            loop
        //不足分の追加
            i = childlen_num
            repeat 1
                j = 0
                repeat len
                    NNWeightBlack.j.i = rnd(101) - 50
                    NNWeightWhite.j.i = rnd(101) - 50
                    j++
                loop
                i++
            loop
        //世代交代
            i = 0
            repeat biont_num
                j = 0
                repeat len
                    NNWeightBlack(j, i) = New_NNWeightBlack(j, i)
                    NNWeightWhite(j, i) = New_NNWeightWhite(j, i)
                    j++
                loop
                i++
            loop

    if(generation_num \ 100 == 0) {
        note_black = ""
        note_white = ""
        i = 0
        repeat len
            notesel note_black
            noteadd "" + NNWeightBlack.i.0

            notesel note_white
            noteadd "" + NNWeightWhite.i.0
            i++
        loop

        notesel note_black
        notesave "black" + str(generation_num) + ".txt"
        
        notesel note_white
        notesave "white" + str(generation_num) + ".txt"
    }

    generation_num++;
    await
loop