celload "画像ファイル/盤面(空).png",100
celload "画像ファイル/盤面(白).png",99
celload "画像ファイル/盤面(黒).png",101
celload "画像ファイル/盤面(候補).png",102
celload "画像ファイル/盤面(カーソル).png",103

square_size = 100
screen 0, square_size * 8, square_size * 8, , ginfo_dispx - 1, 0
dim board,10,10
dim can_count,2
dim dx, 8 : dx = 0, 1, 1, 1, 0, -1, -1, -1
dim dy, 8 : dy = -1, -1, 0, 1, 1, 1, 0, -1


//オセロ
gosub *reset_board

repeat 
    stick key
    gosub *check_can_put
    i = 0
    repeat 2
        if(can_count(i) != 0):break
        i++
    loop
    if(i == 2){
        gosub *draw_board
        break
    }
    if(key == 256){
        putx = mousex / square_size + 1:puty = mousey / square_size + 1
        if(0 <= putx and putx <= 9 and 0 <= puty and puty <= 9){
            if(board(putx,puty) == 2){
                gosub *put_disk
                turn *= -1
            }
        }
    }
    gosub *draw_board
    await
loop
stop

*reset_board
    i = 0:repeat 10:board(i,0) = 10:board(i,9) = 10:board(0,i) = 10:board(9,i) = 10:i++:loop
    board(4,4) = -1:board(5,5) = -1:board(5,4) = 1:board(4,5) = 1

    turn = 1
return

*check_can_put
    can_square_count = 0
    i = 1
    repeat 8
        j = 1
        repeat 8
            if(board(i,j) == 0 || board(i,j) == 2){
                k = 0
                repeat 8
                    if(board(i + dx(k), j + dy(k)) == -turn){
                        l = 1
                        repeat
                            switch board(i + dx(k) * l, j + dy(k) * l)
                                case turn
                                    board(i, j) = 2 : can_square_count++
                                case 0
                                case 10
                                case 2
                                    break
                                swbreak
                            swend
                            l++
                        loop
                    }
                    k++
                loop
            }
            j++
        loop
        i++
    loop
    if(trun == 1):can_count(0) = can_square_count:else:can_count(1) = can_square_count
    if(can_square_count == 0):turn *= -1
return

*draw_board
    redraw 0
        i = 0
        repeat 64
            x = i \ 8 : y = i / 8
            pos square_size * x, square_size * y
            celput board(x + 1, y + 1) + 100,,1.0,1.0
            i++
        loop
    redraw 1
return

*put_disk
    if(board(putx,puty) == 2){
        i = 0
        repeat 8
            k = 1
            repeat
                if(board(putx + k * dx(i),puty + k * dy(i)) == turn){
                    l = 0
                    repeat k + 1
                        board(putx + l * dx(i),puty + l * dy(i)) = turn
                        l++
                    loop
                    break
                }else:if(board(putx + k * dx(i),puty + k * dy(i)) == 2 || board(putx + k * dx(i),puty + k * dy(i)) == 0 || board(putx + k * dx(i),puty + k * dy(i)) == 10){
                    break
                }
                k++
            loop
            i++
        loop
        gosub *clear_candidate
    }
return

*clear_candidate
    i = 1
    repeat 8
        j = 1
        repeat 8
            if(board(i,j) == 2):board(i,j) = 0
            j++
        loop
        i++
    loop
return